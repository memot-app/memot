---
import type { PolymorphicProps } from "~/types";
import type { Slot } from "./FeatureDisplay.astro";

interface CustomProps {
  /**
   * 配置するスロット
   * @see Slot
   * @default 要素の順番に従う
   */
  slot?: Slot;
  videoSrc: string;
  videoPoster?: string;
}

type Props = PolymorphicProps<"div", CustomProps>;

const {
  as: Tag = "div",
  videoSrc,
  videoPoster,
  class: className,
  ...props
} = Astro.props;

const uniqueId = `video-${Math.random().toString(36).substring(2, 9)}`;
---

<Tag
  class:list={[
    "relative flex justify-center items-center p-2 md:p-4 px-4 rounded-3xl gradient-background drop-shadow-hard w-full lg:w-[clamp(320px,100%,500px)] min-h-[clamp(400px,60vh,600px)]",
    className,
  ]}
  {...props}
>
  <div class="flex flex-col items-center gap-4">
    <video
      id={uniqueId}
      class="w-[clamp(200px,60%,280px)] rounded-[clamp(1.5rem,8vw,3rem)] border-4 border-gray-300 overflow-hidden"
      poster={videoPoster}
      preload="metadata"
      muted
      playsinline
    >
      <source src={videoSrc} type="video/mp4" />
      お使いのブラウザは動画をサポートしていません。
    </video>

    <!-- 再生/一時停止ボタン（動画の下） -->
    <button
      id={`control-${uniqueId}`}
      class="flex items-center justify-center gap-2 px-4 py-2 bg-white rounded-full hover:shadow-lg transition-shadow duration-200 text-sm font-medium text-gray-800 mx-auto"
    >
      <!-- 再生アイコン -->
      <svg
        id={`play-icon-${uniqueId}`}
        class="w-4 h-4 ml-0.5"
        fill="currentColor"
        viewBox="0 0 24 24"
        style="display: none;"
      >
        <path d="M8 5v14l11-7z"></path>
      </svg>
      <!-- 一時停止アイコン -->
      <svg
        id={`pause-icon-${uniqueId}`}
        class="w-4 h-4"
        fill="currentColor"
        viewBox="0 0 24 24"
      >
        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path>
      </svg>
      <span id={`button-text-${uniqueId}`}>もう一度再生する</span>
    </button>
  </div>
</Tag>

<style>
  .gradient-background {
    background-color: #5db53e;
    background-image:
      radial-gradient(at 10% 20%, #b9e68f 0px, transparent 50%),
      radial-gradient(at 80% 0%, #9fd467 0px, transparent 50%),
      radial-gradient(at 70% 20%, #ffffff 0px, transparent 40%),
      radial-gradient(at 20% 90%, #5db53e 0px, transparent 50%);
  }

  .drop-shadow-hard {
    box-shadow: 20px 20px 0px 0px rgba(0, 0, 0, 0.8);
  }
</style>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    // Global sequential playback queue to prevent overlapping autoplay
    const w = window as any;
    if (!w.__memotVideoQueue) {
      w.__memotVideoQueue = {
        playing: null as HTMLVideoElement | null,
        queue: [] as HTMLVideoElement[],
        ensureEndedHook(v: HTMLVideoElement) {
          const handler = () => {
            v.setAttribute('data-played', 'true');
            (w.__memotVideoQueue as any).playing = null;
            let next: HTMLVideoElement | undefined;
            while ((w.__memotVideoQueue as any).queue.length > 0 && !next) {
              const cand = (w.__memotVideoQueue as any).queue.shift();
              if (!cand) continue;
              if (!cand.isConnected) continue;
              if (cand.hasAttribute('data-played')) continue;
              next = cand;
            }
            if (next) {
              (w.__memotVideoQueue as any).start(next, /*restart*/ true);
            }
          };
          v.removeEventListener('ended', handler);
          v.addEventListener('ended', handler, { once: true });
        },
        start(v: HTMLVideoElement, restart = false) {
          const mq = w.__memotVideoQueue as any;
          if (mq.playing && mq.playing !== v) {
            try { mq.playing.pause(); } catch {}
          }
          mq.playing = v;
          try { if (restart) v.currentTime = 0; } catch {}
          mq.ensureEndedHook(v);
          v.play().catch(() => { console.log('Auto-play was prevented'); });
        },
        enqueue(v: HTMLVideoElement) {
          const mq = w.__memotVideoQueue as any;
          if (v.hasAttribute('data-enqueued') || v.hasAttribute('data-played')) return;
          v.setAttribute('data-enqueued', 'true');
          if (!mq.playing) {
            mq.start(v, /*restart*/ true);
          } else {
            mq.queue.push(v);
          }
        },
      };
    }
    const g = w.__memotVideoQueue as any;

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const video = entry.target as HTMLVideoElement;
          if (video && !video.hasAttribute('data-played')) {
            // Enqueue for sequential autoplay (do not start immediately)
            (g as any).enqueue(video);
            // Also ensure UI updates when it ends
            video.addEventListener('ended', () => {
              updatePlayPauseButton(video.id, false);
            }, { once: true });
          }
        }
      });
    }, { threshold: 0.5 });

    function updatePlayPauseButton(videoId: string, isPlaying: boolean) {
      const playIcon = document.getElementById(`play-icon-${videoId}`);
      const pauseIcon = document.getElementById(`pause-icon-${videoId}`);
      const buttonText = document.getElementById(`button-text-${videoId}`);

      if (playIcon && pauseIcon && buttonText) {
        if (isPlaying) {
          playIcon.style.display = "none";
          pauseIcon.style.display = "block";
          buttonText.textContent = "一時停止";
        } else {
          playIcon.style.display = "block";
          pauseIcon.style.display = "none";
          buttonText.textContent = "もう一度再生する";
        }
      }
    }

    const videos = document.querySelectorAll('video[id*="video-"]');
    videos.forEach((video) => {
      observer.observe(video);

      const controlButton = document.getElementById(`control-${video.id}`);
      if (controlButton) {
        controlButton.addEventListener("click", () => {
          const videoElement = video as HTMLVideoElement;

          if (videoElement.paused) {
            // Exclusively play this one; pause any other
            (g as any).start(videoElement, /*restart*/ false);
            updatePlayPauseButton(video.id, true);
          } else {
            videoElement.pause();
            updatePlayPauseButton(video.id, false);
          }
        });
      }

      // 動画の再生状態変更を監視
      video.addEventListener("play", () => {
        updatePlayPauseButton(video.id, true);
      });

      video.addEventListener("pause", () => {
        updatePlayPauseButton(video.id, false);
      });
    });
  });
</script>
